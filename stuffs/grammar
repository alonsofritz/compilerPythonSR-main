## GLC

'START -> STMTS',
'STMTS -> DECLARATION_VAR',
'STMTS -> DECLARATION_COM',
'STMTS -> DECLARATION_VAR STMTS',
'STMTS -> DECLARATION_COM STMTS',
'DECLARATION_VAR -> DECLARATION ;',
'DECLARATION_VAR -> DECLARATION INIT ;',
'DECLARATION_VAR -> id ;',
'DECLARATION_VAR -> DECLARATION INIT',
'DECLARATION_VAR -> ASSIGN_STR',
'DECLARATION -> TYPE id',
'INIT -> = TOKEN',
'TYPE -> Number',
'TYPE -> String',
'TYPE -> Boolean',
'TOKEN -> id',
'TOKEN -> number',
'TOKEN -> string',
'TOKEN -> boolean',
'DECLARATION_COM -> DECLARATION_IF',
'DECLARATION_COM -> DECLARATION_FOR',
'DECLARATION_COM -> DECLARATION_WHILE',
'DECLARATION_COM -> DECLARATION_READ',
'DECLARATION_COM -> DECLARATION_WRITE',
'DECLARATION_COM -> DECLARATION_EXP_ARIT',
'DECLARATION_IF -> if ( EXP_REL ) { STMTS }',
'DECLARATION_IF -> if ( EXP_REL ) { STMTS } DECLARATION_ELSE',
'DECLARATION_ELSE -> else { STMTS }',
'DECLARATION_FOR -> for ( id = number , id OP_REL number , id = SIMPLE_EXP ) { STMTS }',
'DECLARATION_WHILE -> while ( EXP_REL ) { STMTS }',
'DECLARATION_READ -> read ( id ) ;',
'DECLARATION_WRITE -> write ( EXP_WRITE ) ;',
'EXP_WRITE -> id',
'EXP_WRITE -> number',
'EXP_WRITE -> string',
'EXP_WRITE -> boolean',
'EXP_WRITE -> ( SIMPLE_EXP )',
'DECLARATION_EXP_ARIT -> id = SIMPLE_EXP ;',
'ASSIGN_STR -> id = string ; ',
'SIMPLE_EXP -> TERM',
'SIMPLE_EXP -> OP_SIGNAL TERM',
'SIMPLE_EXP -> TERM TERM_DERIVATION',
'SIMPLE_EXP -> OP_SIGNAL TERM TERM_DERIVATION',
'TERM -> COEFF',
'TERM -> COEFF COEFF_DERIVATION',
'TERM_DERIVATION -> + OP_SUM_DERIVATION',
'TERM_DERIVATION -> - OP_SUB_DERIVATION',
'OP_SUM_DERIVATION -> TERM',
'OP_SUM_DERIVATION -> TERM TERM_DERIVATION',
'OP_SUB_DERIVATION -> TERM',
'OP_SUB_DERIVATION -> TERM TERM_DERIVATION',
'COEFF -> id ',
'COEFF -> number',
'COEFF -> ( SIMPLE_EXP )',
'COEFF_DERIVATION -> OP_MULDIV COEFF',
'COEFF_DERIVATION -> OP_MULDIV COEFF COEFF_DERIVATION',
'OP_MULDIV -> *',
'OP_MULDIV -> /',
'OP_SIGNAL -> +',
'OP_SIGNAL -> -',
'EXP_REL -> SIMPLE_EXP OP_REL SIMPLE_EXP',
'EXP_REL -> SIMPLE_EXP OP_REL SIMPLE_EXP EXP_REL_DERIVATION',
'EXP_REL_DERIVATION -> OP_COND SIMPLE_EXP OP_REL SIMPLE_EXP',
'EXP_REL_DERIVATION -> OP_COND SIMPLE_EXP OP_REL SIMPLE_EXP EXP_REL_DERIVATION',
'OP_REL -> <',
'OP_REL -> >',
'OP_REL -> <=',
'OP_REL -> >=',
'OP_REL -> ==',
'OP_REL -> <>',
'OP_COND -> and',
'OP_COND -> or',
'OP_COND -> not'

###############################################################################################################

## GRAMMAR TO PARSER
'START -> STMTS',
'STMTS -> DECLARATION_VAR | DECLARATION_COM | DECLARATION_VAR STMTS | DECLARATION_COM STMTS',
'DECLARATION_VAR -> DECLARATION ;',
'DECLARATION_VAR -> DECLARATION INIT ;',
'DECLARATION_VAR -> id ;',
'DECLARATION_VAR -> DECLARATION INIT',
'DECLARATION -> TYPE id',
'INIT -> = TOKEN',
'TYPE -> Number',
'TYPE -> String',
'TYPE -> Boolean',
'TOKEN -> id',
'TOKEN -> number',
'TOKEN -> string',
'TOKEN -> boolean',
'DECLARATION_COM -> DECLARATION_IF',
'DECLARATION_COM -> DECLARATION_FOR',
'DECLARATION_COM -> DECLARATION_WHILE',
'DECLARATION_COM -> DECLARATION_READ',
'DECLARATION_COM -> DECLARATION_WRITE',
'DECLARATION_COM -> DECLARATION_EXP_ARIT',
'DECLARATION_IF -> if ( EXP_REL ) { STMTS }',
'DECLARATION_IF -> if ( EXP_REL ) { STMTS } DECLARATION_ELSE',
'DECLARATION_ELSE -> else { STMTS }',
'DECLARATION_FOR -> for ( id = number , id OP_REL number , id = DECLARATION_EXP_ARIT ) { STMTS }',
'DECLARATION_WHILE -> while ( EXP_REL ) { STMTS }',
'DECLARATION_READ -> read ( id ) ;',
'DECLARATION_WRITE -> write ( EXP_WRITE ) ;',
'EXP_WRITE -> id',
'EXP_WRITE -> number',
'EXP_WRITE -> string',
'EXP_WRITE -> boolean',
'EXP_WRITE -> ( SIMPLE_EXP )',
'DECLARATION_EXP_ARIT -> id = SIMPLE_EXP ',
'SIMPLE_EXP -> TERM',
'SIMPLE_EXP -> OP_SIGNAL TERM',
'SIMPLE_EXP -> TERM TERM_DERIVATION',
'SIMPLE_EXP -> OP_SIGNAL TERM TERM_DERIVATION',
'TERM -> COEFF',
'TERM -> COEFF COEFF_DERIVATION',
'TERM_DERIVATION -> + OP_SUM_DERIVATION',
'TERM_DERIVATION -> - OP_SUB_DERIVATION',
'OP_SUM_DERIVATION -> TERM',
'OP_SUM_DERIVATION -> TERM TERM_DERIVATION',
'OP_SUB_DERIVATION -> TERM',
'OP_SUB_DERIVATION -> TERM TERM_DERIVATION',
'COEFF -> id ',
'COEFF -> number',
'COEFF -> ( SIMPLE_EXP )',
'COEFF_DERIVATION -> OP_MULDIV COEFF',
'COEFF_DERIVATION -> OP_MULDIV COEFF COEFF_DERIVATION',
'OP_MULDIV -> *',
'OP_MULDIV -> /',
'OP_SIGNAL -> +',
'OP_SIGNAL -> -',
'EXP_REL -> SIMPLE_EXP OP_REL SIMPLE_EXP',
'EXP_REL -> SIMPLE_EXP OP_REL SIMPLE_EXP EXP_REL_DERIVATION',
'EXP_REL_DERIVATION -> OP_COND SIMPLE_EXP OP_REL SIMPLE_EXP',
'EXP_REL_DERIVATION -> OP_COND SIMPLE_EXP OP_REL SIMPLE_EXP EXP_REL_DERIVATION',
'OP_REL -> <',
'OP_REL -> >',
'OP_REL -> <=',
'OP_REL -> >=',
'OP_REL -> ==',
'OP_REL -> <>',
'OP_COND -> and',
'OP_COND -> or',
'OP_COND -> not'

###############################################################################################################

## PRODUCTIONS


################################################################################################################

## BNF
<START> ::= <STMTS> 
<STMTS> ::= <DECLARATION_VAR> | <DECLARATION_COM> | <DECLARATION_VAR> <STMTS> | <DECLARATION_COM> <STMTS> 
<DECLARATION_VAR> ::= <DECLARATION> ; | <DECLARATION> <INIT> ; | id ; | <DECLARATION> <INIT> 
<DECLARATION> ::= <TYPE> id 
<INIT> ::= = <TOKEN> 
<TYPE> ::= Number | String | Boolean 
<TOKEN> ::= id | number | string | boolean 
<DECLARATION_COM> ::= <DECLARATION_IF> | <DECLARATION_FOR> | <DECLARATION_WHILE> | <DECLARATION_READ> | <DECLARATION_WRITE> | <DECLARATION_EXP_ARIT> 
<DECLARATION_IF> ::= if ( <EXP_REL> ) { <STMTS> } | if ( <EXP_REL> ) { <STMTS> } <DECLARATION_ELSE> 
<DECLARATION_ELSE> ::= else { <STMTS> } 
<DECLARATION_FOR> ::= for ( id = number  id <OP_REL> number  id = <DECLARATION_EXP_ARIT> ) { <STMTS> } 
<DECLARATION_WHILE> ::= while ( <EXP_REL> ) { <STMTS> } 
<DECLARATION_READ> ::= read ( id ) ; 
<DECLARATION_WRITE> ::= write ( <EXP_WRITE> ) ; 
<EXP_WRITE> ::= <TOKEN> ;| ( <SIMPLE_EXP> ) ; 
<DECLARATION_EXP_ARIT> ::= id = <SIMPLE_EXP> ; 
<SIMPLE_EXP> ::= <TERM> | <OP_SIGNAL> <TERM> | <TERM> <TERM_DERIVATION> | <OP_SIGNAL> <TERM> <TERM_DERIVATION> 
<TERM> ::= <COEFF> | <COEFF> <COEFF_DERIVATION> 
<TERM_DERIVATION> ::= + <OP_SUM_DERIVATION> | - <OP_SUB_DERIVATION> 
<OP_SUM_DERIVATION> ::= <TERM> | <TERM> <TERM_DERIVATION> 
<OP_SUB_DERIVATION> ::= <TERM> | <TERM> <TERM_DERIVATION> 
<COEFF> ::= id | number | ( <SIMPLE_EXP> ) 
<COEFF_DERIVATION> ::= <OP_MULDIV> <COEFF> | <OP_MULDIV> <COEFF> <COEFF_DERIVATION> 
<OP_MULDIV> ::= * | /
<OP_SIGNAL> ::= + | -
<EXP_REL> ::= <SIMPLE_EXP> <OP_REL> <SIMPLE_EXP> | <SIMPLE_EXP> <OP_REL> <SIMPLE_EXP> <EXP_REL_DERIVATION> 
<EXP_REL_DERIVATION> ::= <OP_COND> <SIMPLE_EXP> <OP_REL> <SIMPLE_EXP> | <OP_COND> <SIMPLE_EXP> <OP_REL> <SIMPLE_EXP> <EXP_REL_DERIVATION> 
<OP_REL> ::= < | > | <= | >= | == | <>
<OP_COND> ::= and | or | not